//Tang, Chen
//Jan 17 2019
//Analyze the survey responses

package finalproject.tang.chen;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import javax.swing.JOptionPane;

/**
 *
 * @author mache9294
 */
public class AnalyzeSurveyResponse extends javax.swing.JFrame {

    private Survey survey;
    private ArrayList<Question> questions;
    private ArrayList<String> questionNames;
    private ArrayList<String> questionTypeOrder;
    private ArrayList<String> criteriaSelected = new ArrayList();
    private String criteriaName = null;
    private String surveyName;
    private int numCriterias = 0;

    private BarGraph barGraphWindow;
    private PieGraph pieGraphWindow;

    /**
     * Creates new form AnalyzeSurveyResponse
     */
    public AnalyzeSurveyResponse(String surveyName, Survey survey, ArrayList<String> questionTypeOrder) {
        initComponents();
        //Establish the survey object, the name of the survey, and the order of the questions (in type)
        this.survey = survey;
        this.surveyName = surveyName;
        this.questionTypeOrder = questionTypeOrder;

        //Establish the survey object by calling the establishSurveyResponseSide method
        establishSurveyResponseSide();
        
        //Use accessor to get the ArrayList of questions of the survey
        questions = survey.getSurveyQuestions();
        
        //Establish the ArrauList of the names of the questions
        questionNames = new ArrayList();
        
        //Establish the list of the names of the questions
        establishQuestionList();
        
        //Establish the combo box of the questions
        for (int i = 0; i < questionNames.size(); i++) { //Runs as many times as the number of questions
            jComboBoxQuestion.addItem(questionNames.get(i)); //Add the name of the question to the combo box
        }

    }

    /**
     * Establishes the list of names of questions
     */
    public void establishQuestionList() {
        for (int i = 0; i < questions.size(); i++) { //Runs for the number for the times as the number
            String question = questions.get(i).getQuestion();//Obtain the question (title) attribute of the question
            questionNames.add(question);//Add title to arrayList
        }
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        lblTitle = new javax.swing.JLabel();
        jComboBoxQuestion = new javax.swing.JComboBox();
        jComboBoxCriteria = new javax.swing.JComboBox();
        lblQuestion = new javax.swing.JLabel();
        lblCriteria = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        txtCriteriaSelected = new javax.swing.JTextArea();
        jScrollPane2 = new javax.swing.JScrollPane();
        txtOutCriteria = new javax.swing.JTextArea();
        lblQuestionAndCriteria = new javax.swing.JLabel();
        lblFindings = new javax.swing.JLabel();
        btnGo = new javax.swing.JButton();
        btnClearCriteria = new javax.swing.JButton();
        btnGraphsShow = new javax.swing.JButton();
        jLabel1 = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        lblTitle.setText("Survey Analysis");

        jComboBoxQuestion.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jComboBoxQuestionActionPerformed(evt);
            }
        });

        jComboBoxCriteria.setDoubleBuffered(true);
        jComboBoxCriteria.setEditor(null);
        jComboBoxCriteria.setFocusCycleRoot(true);
        jComboBoxCriteria.setKeySelectionManager(null);
        jComboBoxCriteria.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                jComboBoxCriteriaMouseClicked(evt);
            }
        });
        jComboBoxCriteria.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jComboBoxCriteriaActionPerformed(evt);
            }
        });

        lblQuestion.setText("Question");

        lblCriteria.setText("Criteria");

        txtCriteriaSelected.setColumns(20);
        txtCriteriaSelected.setRows(5);
        jScrollPane1.setViewportView(txtCriteriaSelected);

        txtOutCriteria.setColumns(20);
        txtOutCriteria.setRows(5);
        jScrollPane2.setViewportView(txtOutCriteria);

        lblQuestionAndCriteria.setText("Question And Criteria");

        lblFindings.setText("Findings Based On Criteria");

        btnGo.setText("Go");
        btnGo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnGoActionPerformed(evt);
            }
        });

        btnClearCriteria.setText("Clear Criteria");
        btnClearCriteria.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnClearCriteriaActionPerformed(evt);
            }
        });

        btnGraphsShow.setText("See Graph Of Question");
        btnGraphsShow.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnGraphsShowActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(lblTitle)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jComboBoxQuestion, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(lblQuestion))
                        .addGap(55, 55, 55)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(lblCriteria, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(jComboBoxCriteria, 0, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                        .addGap(60, 60, 60)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(btnGraphsShow)
                            .addComponent(btnClearCriteria))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(btnGo))
                    .addComponent(lblFindings)
                    .addComponent(lblQuestionAndCriteria)
                    .addComponent(jScrollPane1)
                    .addComponent(jScrollPane2))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 6, Short.MAX_VALUE)
                .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 27, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(311, 311, 311))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 408, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()
                        .addComponent(lblTitle)
                        .addGap(33, 33, 33)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(lblQuestion)
                            .addComponent(lblCriteria))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jComboBoxQuestion, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jComboBoxCriteria, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(btnClearCriteria)
                            .addComponent(btnGo))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(btnGraphsShow)
                        .addGap(21, 21, 21)
                        .addComponent(lblQuestionAndCriteria)
                        .addGap(18, 18, 18)
                        .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 98, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(lblFindings)
                        .addGap(13, 13, 13)
                        .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap(67, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jComboBoxQuestionActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jComboBoxQuestionActionPerformed

        String questionName = jComboBoxQuestion.getSelectedItem().toString(); // get the name of the question
        String questionType = "";//Set the questionType as blank

        jComboBoxCriteria.removeAllItems();//Remove all items in the criteria combo box
        btnGraphsShow.setEnabled(true);//Allow the button that will display the graph

        for (int i = 0; i < questions.size(); i++) { // run thru survey questions

            if (questionName.equals(questions.get(i).getQuestion())) { // compare actual question? in survey
                
                questionType = questions.get(i).getType(); // get type

                if (questionType.equals("Single Response Multiple Choice")) { //Check if the question is a Single Response Multiple Choice question
                    
                    SingleMC question = (SingleMC) questions.get(i);//Get the question
                    
                    for (int j = 0; j < question.getAnswers().size(); j++) {//Get the choices of the question
                        
                        if (!question.getAnswers().get(j).equals(" ")) { //Check if its a valid response
                            jComboBoxCriteria.addItem(question.getAnswers().get(j)); //Add the resposne to the combo box
                        }

                    }
                } else if (questionType.equals("Multiple Response Multiple Choice")) {//Check if the question is a Multiple Response Multiple Choice question
                    
                    MultipleMC question = (MultipleMC) questions.get(i);//Get the question
                    
                    for (int j = 0; j < question.getAnswers().size(); j++) {//Get the choices of the question
                       
                        if (!question.getAnswers().get(j).equals(" ")) {//Check if its a valid response
                            jComboBoxCriteria.addItem(question.getAnswers().get(j));//Add the resposne to the combo box
                        }
                        
                    }
                } else if (questionType.equals("Short Answer")) {//Check if the question is a short answer question
                    
                    ShortAnswer question = (ShortAnswer) questions.get(i);//Get the question
                    txtOutCriteria.setText("No analysis for Short Answer Question: " + question.getQuestion());//Display the statement that there are no choices available.
                    btnGraphsShow.setEnabled(false);//Not allow the users to see a graph (there does not exist one)
                    
                }
            }

        }
    }//GEN-LAST:event_jComboBoxQuestionActionPerformed

    /**
     * Display results specific of criteria
     * @param evt The "Go" button is clicked
     */
    private void btnGoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnGoActionPerformed
        String out = "";
        ArrayList<String[]> criteriaSet = takeCriteriaIntoArrays(); //Establish the ArrayList of criterias
        txtOutCriteria.setText(out);//Clear the findings (so old findings will go away
        getSatisfyingResponses(criteriaSet);//Call on method to determine the possible survey responses and display results
    }//GEN-LAST:event_btnGoActionPerformed

    /**
     * Clear all criterias
     * @param evt "Clear Criteria" button is clicked
     */
    private void btnClearCriteriaActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnClearCriteriaActionPerformed
        criteriaSelected.clear();//Clear array of criterias.
        showCriteriaToGUI(); //This will show nothing
        txtOutCriteria.setText(""); //Set the text of the results to nothing. Old results will not stay there.
        numCriterias = 0;//Reset counter for the number of criterias.
        btnGraphsShow.setEnabled(true);//Allow users to display graph. 
    }//GEN-LAST:event_btnClearCriteriaActionPerformed

    /**
     * Enter the criteria into array
     * @param evt Click on the choices of combo box (not the arrow)
     */
    private void jComboBoxCriteriaMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jComboBoxCriteriaMouseClicked
        String questionName = jComboBoxQuestion.getSelectedItem().toString();//Get the question name
        criteriaName = jComboBoxCriteria.getSelectedItem().toString();//Get the criteria name
        criteriaSelected.add(questionName + " - " + criteriaName);//Add the criteria to the ArrayList of criterias
        showCriteriaToGUI();//Display all criterias
        numCriterias ++;//Increase counter for the number of criterias
        
        if(numCriterias > 1){//If there are more than 1 criteria (question)
            btnGraphsShow.setEnabled(false);//Do not allow user to see graph. It is not possible. 
        }
        
    }//GEN-LAST:event_jComboBoxCriteriaMouseClicked

    /**
     * Show the graphs
     * @param evt Click on the "See Graph Of Question" button
     */
    private void btnGraphsShowActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnGraphsShowActionPerformed
        if (questionTypeOrder.get(jComboBoxQuestion.getSelectedIndex()).equalsIgnoreCase("Single Response Multiple Choice")) {//Check if the question is a single response multiple  choice question
            
            //Establish pie graph object
            if (pieGraphWindow == null) {//If the graph does not exist
                pieGraphWindow = new PieGraph("SingleMC", (SingleMC) survey.getSurveyQuestions().get(jComboBoxQuestion.getSelectedIndex()));//Establish new pie graph
            }
            
            pieGraphWindow.setVisible(true);//Display pie graph
            
        } else if (questionTypeOrder.get(jComboBoxQuestion.getSelectedIndex()).equalsIgnoreCase("Multiple Response Multiple Choice")) {//Check if the question is a multiple response multiple choice question
            
            int questionNumber = 0;//Just set the question number to something. Will be overrided
            
            MultipleMC question = new MultipleMC();//Establish new question
            question.setQuestion(jComboBoxQuestion.getSelectedItem().toString());//Set the question title of the question object
            
            try{
                
                //Establish FileReader and BufferedReader reading the responses file
                FileReader fr = new FileReader("src\\finalproject\\tang\\chen\\" + surveyName + " RESPONSES");
                BufferedReader br = new BufferedReader (fr); 
                boolean eof = false;//Establish the end of file boolean as false
                while(!eof){//while it is not end of file
                    
                    String response = br.readLine();//Read line of response
                    
                    if(response == null){//If the line is empty
                        eof = true;//End of file is true
                    }else{
                        
                        for(int i = 0; i < questionNames.size(); i++){//Check for all possible question numbers
                            if(question.getQuestion().equals(questionNames.get(i))){//If the question title is equal to the desired title (It should happen at some point)
                                questionNumber = i;//Set the question number
                            }
                        }
                        
                        String process = response; //Establish new process string (to be processed)
                        
                        for(int i = 0; i < questionNumber; i++){//Run for the number of times as the question number 
                            //Split response into the array
                            int commaSpot = response.indexOf(",");//Find the next comma spot
                            process = process.substring(commaSpot + 1);//Only keep the part of the string after the comma
                        }
                        
                        int commaSpot = response.indexOf(",");//Find the next comma spot
                        process = process.substring(0, commaSpot); //Only keep the part of the string before the comma
                        process = "," + process;//Add comma in front for processing
                        
                        for(int i = 0; i < 12; i++){//For all possible choices
                            
                            if(response.lastIndexOf("." + i + ".") != -1 || response.lastIndexOf("," + i + ".") != -1){//Check if the user selected the choice
                                
                                int responses[] = question.getCollectionOfAnswers();//Get the result of the user selected answers
                                responses[i]++;//Increment the number of responses for the required index
                                ((MultipleMC) survey.getSurveyQuestions().get(questionNumber)).setUserSelectedAnswers(responses);//Set the results for the question to the new array (updated)
                            
                            }
                        }
                        
                    }
                }
            }catch(IOException e){
                System.out.println("ERROR " + e);
            }
            
            //Draw bar graph
            if (barGraphWindow == null) {//If there is now bar graph
                //Make a new bar graph object
                barGraphWindow = new BarGraph("MultipleMC", "", ((MultipleMC) survey.getSurveyQuestions().get(questionNumber)),((MultipleMC) survey.getSurveyQuestions().get(questionNumber)).getUserSelectedAnswers());
            }
            
            barGraphWindow.setVisible(true);//Display the bar graph
            
        }

    }//GEN-LAST:event_btnGraphsShowActionPerformed

    private void jComboBoxCriteriaActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jComboBoxCriteriaActionPerformed
        // Can't get rid of this. 
    }//GEN-LAST:event_jComboBoxCriteriaActionPerformed
    
    /**
     * Display criteria
     */
    private void showCriteriaToGUI() {
        
        String out = "";
        
        //For the number of criterias, add the criteria to the string
        for (int i = 0; i < criteriaSelected.size(); i++) {
            out += criteriaSelected.get(i) + "\n";
        }
        
        txtCriteriaSelected.setText(out);//Display criteria
    }

    /**
     * This method takes the user's selected criteria and converts the string value of input into the indexes respective to the question attributes and survey questions
     * @return the list of criteria, - the question and the criteria parameter
     */
    private ArrayList<String[]> takeCriteriaIntoArrays() {
        //Gets the user selected criteria
        String allCriteria = txtCriteriaSelected.getText();
        
        //Break the criteria into individual question and criteria
        String[] brokenDownCriteria = allCriteria.split("\n");

        //Create a the variable to store all criteria and questions
        ArrayList<String[]> setOfCriteria = new ArrayList();
        
        //Get the number of criteria to inspect
        int lengthOfTextToRead = brokenDownCriteria.length;
        
        //Set up each criteria to be able to contain a question and an actual answer of the question
        String[] questionAndCriteria = new String[2];
        
        //For every criteria chosen
        for (int i = 0; i < lengthOfTextToRead; i++) {
            
            //Seperate the question and the criteria
            questionAndCriteria = brokenDownCriteria[i].split(" - ");
            
            //Set the index of the criteria as the new criteria to be stored
            questionAndCriteria[1] = getIndexOfCriteria(questionAndCriteria) + "";
            
            //Add the new criteria to the list of criterias
            setOfCriteria.add(questionAndCriteria);

        }
        return setOfCriteria;
    }

    /**
     * Get the criterias
     * @param questionAndCriteria the string of criterias and the question number
     * @return the index of criteria
     */
    private int getIndexOfCriteria(String[] questionAndCriteria) { // Makes the chosen criteria into question name and index chosen
        int indexOfCriteria = -1;
        String questionType;
        String choice = questionAndCriteria[1];
        for (int i = 0; i < questionNames.size(); i++) {
            if (questionNames.get(i).equalsIgnoreCase(questionAndCriteria[0])) {
                questionAndCriteria[0] = i + "";
                questionType = questions.get(i).getType(); // get type

                if (questionType.equals("Single Response Multiple Choice")) {
                    SingleMC question = (SingleMC) questions.get(i);

                    for (int j = 0; j < question.getAnswers().size(); j++) {
                        if (choice.equalsIgnoreCase(question.getAnswers().get(j))) {
                            return j;
                        }
                    }

                } else if (questionType.equals("Multiple Response Multiple Choice")) {
                    MultipleMC question = (MultipleMC) questions.get(i);

                    for (int j = 0; j < question.getAnswers().size(); j++) {
                        if (choice.equalsIgnoreCase(question.getAnswers().get(j))) {
                            return j;
                        }
                    }

                } else if (questionType.equals("Short Answer")) {
                    JOptionPane.showMessageDialog(null, "No Index For Short Answer");
                } else {
                    //No questions
                }
                i = questionNames.size() + 1; // Stop search for this specific question
            }
        }
        return indexOfCriteria;
    }

    public void responseSort() {
        try {
            //Create the file readers for the file
            String filePath = "src\\finalproject\\tang\\chen\\";
            FileReader fr = new FileReader(filePath + surveyName + " Responses");
            BufferedReader br = new BufferedReader(fr);

            ArrayList<String> responsesLineByLine = new ArrayList(); //This part loads in the response file into array list of string array

            String finalOutSorted = "";
            
            //Establish the ArrayList of responses
            ArrayList<String[]> allResponses = new ArrayList();

            String line;
            
            boolean eof = false;
            while (!eof) {//while the file is not empty
                
                line = br.readLine();//Read the line of the file
                
                if (line == null) {//If the line is empty
                    eof = true;//It is the end of the file
                } else {
                    responsesLineByLine.add(line);//Add to the responses ArrayList
                }
            }

            for (String response : responsesLineByLine) {//For each of the responses
                allResponses.add(response.split(","));//Establish array of responses
            }

            //This part will begin to sort
            getSatisfyingResponses(allResponses);

            //Prints
            PrintWriter pw = new PrintWriter(filePath + surveyName + " RESPONSES");
            pw.print(finalOutSorted);
            pw.close();

        } catch (IOException e) {
            System.out.println("ERROR " + e);
        }

    }

    /**
     * This will establish the responses satisfying the requirements
     * @param criterias The desired criterias
     */
    public void getSatisfyingResponses(ArrayList<String[]> criterias) {
        
        ArrayList<String[]> responses = new ArrayList(); //Instantiate new ArrayList containing the responses
        
        try{
            //Create FileReader and BufferedReader for the responses file
            FileReader fr = new FileReader("src\\finalproject\\tang\\chen\\" + surveyName + " RESPONSES");
            BufferedReader br = new BufferedReader(fr);
            //Set so it is not the end of the file
            boolean eof = false;
            //While it is not the end of the file
            while(!eof){
                String response = br.readLine();
                if(response == null){//If the line is empty
                    eof = true;//It is the end of the file
                }else{
                    String[] thisResponse = new String[survey.getSurveyQuestions().size() + 1];//Establish new String array of the same size as the number of questions in the survey
                    for(int i = 0; i <= survey.getSurveyQuestions().size(); i++){ //Run for the same of the time as the number of questions in the survey
                        //Split response into the array
                        int commaSpot = response.indexOf(",");//Find the next comma spot
                        String responseQuestion = response.substring(0,commaSpot);//Extrapolate the response for that question
                        thisResponse[i] = responseQuestion;//Iinput the response into the array
                        response = response.substring(commaSpot + 1);//Only keep the part of the string after the comma
                    }
                    responses.add(thisResponse);//Add the array containing this user's response into the ArrayList of responses
                }
            }
        }catch(IOException e){
            System.out.println("ERROR " + e);
        }
        for(int i = 0; i < criterias.size(); i++){ //Run as many times as the number of criterias
            int questionNumber = Integer.parseInt((criterias.get(i))[0]);//Get the question number of the criteria
            int desiredResponse = Integer.parseInt((criterias.get(i))[1]);//Get the desired response for that question
            ArrayList<String> responseForQuestion = new ArrayList();//Create ArrayList of responses for that question
            ArrayList<String> responseNumber = new ArrayList();//Create ArrayList of response numbers
            ArrayList<Integer> responsesThatSatisfy = new ArrayList();//Create ArrayList that will be filled by the responses that satisfy the criteria(s)
            
            for(int a = 0; a < responses.size(); a++){//Run as many times as the number of responses
                responseForQuestion.add((responses.get(a))[questionNumber+1]);//Add the responses to the ArrayList
                responseNumber.add(responses.get(a)[0]);//The the response number
            }
            
            if(questionTypeOrder.get(questionNumber).equals("Single Response Multiple Choice")){//Check if the type of question outlined by this criteria is a single response multiple choice question
                int response[][] = new int [2][responses.size()];//Create array that will contain the response and response numbers for this question
                int minSatisfy = 0; //For later finding purposes
                int maxSatisfy = responses.size() - 1; //For later finding purposes
                for(int j = 0; j < responses.size(); j++){//Runs for the same number of times as the number of responses
                    response[0][j] = Integer.parseInt(responseForQuestion.get(j));//Fill in the responses
                    response[1][j] = Integer.parseInt(responseNumber.get(j));//Fill in the responseNumbers
                }
                
                //We are going to combine the two numbers before we sort. The response is going to be immediately followed by the response number 
                int toBeSorted[] = new int[responses.size()];//Set the array that will eventually be sorted
                for(int j = 0; j < responses.size(); j++){//Run for the same number of times as the number of responses
                    toBeSorted[j] = 1000 * response[0][j] + response[1][j];//Multiply the response by 1000 add it to the response number. Now we have an array of numbers that will be sorted
                }
                
                QuickAscending(toBeSorted, 0, responses.size() - 1); //Sort these numbers using quiksort
                
                //Now we are going to obtain the responses and the corresponding response numbers separately and sorted. 
                //Note this means that the program will only accept 999 responses.
                for(int j = 0; j < responses.size(); j++){//Run for the same number of times as the number of responses
                    response[0][j] = toBeSorted[j] /1000;//Obtain the response by diving by 1000
                    response[1][j] = toBeSorted[j] % 1000;//Obtain the question number by applying mod 1000
                }
                
                //Now we extrapolate the responses that satisfy the particular criteria. 
                //Find the minimum index of response that satisfy needs.
                while(response[0][minSatisfy] < desiredResponse){//Run while the response's response to that question is smaller than the desired response
                    minSatisfy ++; //Move on to the next response
                } 
                
                //Find the maximum index of response that satisfy needs.
                while(response[0][maxSatisfy] > desiredResponse){//Run while the response's response to that question is larger than the desired response backwards
                    maxSatisfy --;//Move on to the next response
                }
                
                //Establish the ArrayList of response (numbers) that satisfy the criteria
                for(int k = minSatisfy; k <= maxSatisfy; k++){//From the minimum response index containing the number representing the desired response to the maximum
                    responsesThatSatisfy.add(response[1][k]);//Add the response number to the ArrayList of responses satisfying the criteria
                }
                
            }else if(questionTypeOrder.get(questionNumber).equals("Multiple Response Multiple Choice")){//Check if the type of question outlined by this criteria is a single response multiple choice question
                for(int j = 0; j < responses.size(); j++){//Run for the same number of times as the number of responses
                    String process = "," + responseForQuestion.get(j);//Get the string representing all the responses
                    if(process.contains("." + desiredResponse + ".") == true || process.contains("," + desiredResponse + ".") == true){//Check if the string contains the number that represents the desired response
                        responsesThatSatisfy.add(Integer.parseInt((responses.get(j))[0]));//If so, add the response number to the ArrayList of responses satisfying the criteria
                    }
                }
            }
            
            //Re-establish the arrayList so that it only contaiss the responses satisfying the requirement
            for(int x = responses.size() - 1; x >= 0; x--){//Checks all the original responses in original order
                boolean satisfyRequirements = false;//Assume the requirements is not made
                for(int y = 0; y < responsesThatSatisfy.size(); y++){//For all the numbers that represent the successful responses
                    if(Integer.parseInt((responses.get(x))[0]) == responsesThatSatisfy.get(y)){//Check if the response number is a satisfying response number
                        satisfyRequirements = true;//If so - the requirements are made
                    }
                }
                if(satisfyRequirements == false){//If the requirements are not made
                    responses.remove(x);//Remove the response from the list
                }
            }
        }
        txtOutCriteria.setText("The number of survey responses satisfying the criterias is " + responses.size());
    }

     /**
     * This will sort the array in quicksort  in ascending order
     * @param numbers The array of numbers to be sorted
     */
    public static void QuickAscending(int[] numbers, int low, int high){
        
        if(low < high){//Check if the leftmost index is greater then the rightmost index
            
            int partitionIndex = partitionAscending(numbers,low,high); //Invoke the method to partition the numbers in the way that the numbers greater than the pivot point
            
            QuickAscending(numbers, low, partitionIndex - 1); //Recursive call to quick sort the numbers left of pivot point after partitioning
            QuickAscending(numbers,partitionIndex + 1, high) ;//Recursive call to quick sort the numbers right of pivot point after partitioning
            
        }
        
    }

    /**
     * This method partitions the numbers in the way that the numbers greater than the pivot numbers will be on the right of the pivot number and the numbers smaller than the pivot number will be on the left of pivot number
     * @param numbers The array of numbers to be partitioned
     * @param low The index of the left most element to be partitioned
     * @param high The index of the right most element to be partitioned
     * @return 
     */
    public static int partitionAscending(int[] numbers, int low, int high){
        
        int pivot = numbers[high]; //Make the rightmost number be the pivot
        int wall = low - 1; //Set the wall to be at the left of the lowest spot
        
        for(int i = low; i < high; i++){ //Will check for the number of times as the number of numbers to be sorted
            
            if(numbers[i] < pivot){//Check if the number at index i is less than the pivot
                
                //If so, move the numbers to the immediate right of the wall. In the meantime, we move the number immediately to the right of the wall to index i
                int temp = numbers[wall+1]; //Store the number immediate right of the wall in a temporary variable
                numbers[wall+1] = numbers[i]; //Change the number immediately to the right of the wall to the number at index i
                numbers[i] = temp; //Fill index i with the number stored in temporary variable
                
                wall++;//Move the wall to the left 
                
            }
            
        }
        
        //Now we move the number at the pivot to the immediate right of the wall
        int temp = numbers[wall+1]; //Store the number immediate right of the wall in a temporary variable
        numbers[wall+1] = numbers[high]; //Change the number immediately to the right of the wall to the pivot
        numbers[high] = temp; //Fill the right most memory space with the number stored in temporary variable
        
        return (wall + 1); //(wall+1) contains the pivot number. Will return this pivot number so that we can sort the numbers to the left and to the right of this pivot number 
        
    }

    public void establishSurveyResponseSide() {
        try {
            //Establish File and Buffer Readers of the responses
            String filePath = "src\\finalproject\\tang\\chen\\" + surveyName + " RESPONSES";
            FileReader fr = new FileReader(filePath);
            BufferedReader br = new BufferedReader(fr);
            //Establish the questionAnswer, indexList arrays and responseLine, and type 
            String[] eachQuestionAnswer, listOfIndexes;
            String responseLine, type;
            
            boolean eof = false;
                    
            while (!eof) {//while file is not empty

                responseLine = br.readLine();//Read Line
                
                if (responseLine == null){ //If the line is empty it is the end of the file
                    
                    eof = true;
                    
                } else {//Otherwise
                    
                    int length = responseLine.length();//Get the length of the string object
                    String withoutComma = responseLine.substring(0, length - 1);//Establish the array to be processed
                    eachQuestionAnswer = withoutComma.split(",");//Establish the array of answers
                    
                    for (int i = 0; i < questionTypeOrder.size(); i++) {//For each element of the answers array
                        
                        type = questionTypeOrder.get(i);//Get the type of question

                        if (type.equalsIgnoreCase("Single Response Multiple Choice")) {
                            
                            ((SingleMC) survey.getSurveyQuestions().get(i)).setUserSelected(Integer.parseInt(eachQuestionAnswer[i+1]));//Set the user selected answer array
                            
                        } else if (type.equalsIgnoreCase("Multiple Response Multiple Choice")) {
                            
                            listOfIndexes = eachQuestionAnswer[i].split(".");
                            //String to int
                            int[] listOfIndexNumbers = new int[listOfIndexes.length];
                            for (int j = 0; j < listOfIndexes.length; j++) {
                                listOfIndexNumbers[j] = Integer.parseInt(listOfIndexes[j]);
                            }
                            
                            ((MultipleMC) survey.getSurveyQuestions().get(i)).setUserSelectedAnswers(listOfIndexNumbers);//Set the user selected answer array

                        } else {
                            
                            ((ShortAnswer) survey.getSurveyQuestions().get(i)).setAnswer(eachQuestionAnswer[i]);//Set the answers of the short answer question
                            
                        }
                    }
                }
            }
        } catch (IOException e) {
            System.out.println("ERROR " + e);
        }
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btnClearCriteria;
    private javax.swing.JButton btnGo;
    private javax.swing.JButton btnGraphsShow;
    private javax.swing.JComboBox jComboBoxCriteria;
    private javax.swing.JComboBox jComboBoxQuestion;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JLabel lblCriteria;
    private javax.swing.JLabel lblFindings;
    private javax.swing.JLabel lblQuestion;
    private javax.swing.JLabel lblQuestionAndCriteria;
    private javax.swing.JLabel lblTitle;
    private javax.swing.JTextArea txtCriteriaSelected;
    private javax.swing.JTextArea txtOutCriteria;
    // End of variables declaration//GEN-END:variables
}
